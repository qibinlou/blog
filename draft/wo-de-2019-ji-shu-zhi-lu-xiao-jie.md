# 我的2019技术之路小结

时间飞逝，19年即将进入尾声，子曰：温故而知新，作为一个在技术之路上孜孜不倦地奋斗的一线软件工程师，今天就来回顾总结下19年的技术之路，以作承上启下之用。

首先向不甚知情的读者简单介绍下笔者现在的工作：我目前就职于纽约的成长型创业公司Squarespace，公司的主营业务是零代码自主建站（个人网站或电商网站），域名，邮件营销工具。同行业的可参考对比的公司包括Wix\(6B\), Shopify\(45B\), Godaddy\(11B\), MailChimp\(5B估值）。我主要在做电商网站建站那块业务，上至前端的购物车应用、结算应用、商家产品管理、订单管理，下至后端的订单系统和支付系统，都有所涉及。在小公司工作的好处之一就是粥多僧少，只要肯干活有的是项目，能学到的东西自然也就比较多。

19年做的项目基本都是后端的项目，最主要的两个大项目是 1）构建第二代订单系统以提高系统容错性 2）全链路实现Stripe SCA来迎合欧洲新出的关于支付两步验证的法规。

#### 

#### 构建第二代订单系统

在Google Search工作时，我有个印象是比较核心的infra系统基本每过个两三年都要重做一次，因为数据量增长实在太大或者是老系统的性能出现明显业务瓶颈。现在业界很火的一个话题是微服务架构\(Microservices\)，采用这种系统架构的好处很明显，在一个几百个人的工程团队里分工明确，责任明确，开发测试部署效率都比在单体应用时代有了显著的提升（毕竟能做到像Google那样所有人都在google3一个monorepo里写代码并快速部署子系统迭代的公司寥寥无几，对infra的要求太高，小公司没能力也没精力去做\)。但微服务并非万能钥匙，凡事有利必有弊，其中一个大弊端就是整体系统稳定性降低，如果没有做好容错的话，很容易出现单点故障导致线上事故。

在单体应用时代，假设我们只有一个系统X，X的稳定性是99.99%, 也就是说10000分钟里最多宕机1分钟。但在微服务架构下，我们把X拆成了三个各自分工相对松耦合的微服务A, B, C, 三个子系统的稳定性假设也是99.99%， 但从整体来看系统的稳定性变成了 `99.99% * 99.99% * 99.99% = 99.97%`！这里还有个隐藏假设是该系统的功能依赖A, B, C三个系统同时可用。

现在我们来把A, B, C具象化下，场景为电商网站的订单提交请求处理。 A为库存更新，B为支付，C为创建订单，依次进行，A和B必须同时成功完成C才能开始。A、B、C很自然地可以用Domain Driven Design的设计思路用三个微服务来实现其API，并在上游调用系统S中调用`S -> (A ->B -> C)`。这时假设B支付服务出故障了，原因是依赖的外部支付系统Stripe出故障了，那段时间的所有订单都不能创建，而且已经完成的库存更新必须得撤销\(Rollback\)来保证一致性。注意A、B、C为三个独立系统，可由不同的编程语言和不同的数据库来实现，无法通过底层关系型数据库的事务性\(transaction\)来实现强一致性\(Strong consistency\)。假设C订单服务出故障了，原因是底层的数据库数据遇到性能瓶颈开始挂断连接，理论上S可以重试几次，但重试只能解决偶然性的系统问题，不能拿解决持续性的系统问题，毕竟用户在前端页面等着呢，你不能让他们等个十分钟，估计好多人都或刷新或放弃关闭页面了。按照之前的逻辑，S此时要撤销B的支付和A的库存更新，但撤销一个完成的支付说易行难，尤其是其实现是使用外部支付系统，比如Stripe，PayPal，WorldPay等，中间会有不同的cost产生。所以实际操作里会发现如果C出故障了，整个订单请求被挂断，但是用户的钱却被扣了！这时平台或者商家不得不手动联系买家处理这些没有订单的支付记录。

以上简述就是我们上一代的订单系统碰到的诸多头疼的问题之一。因为这些问题在过去两年我们平台发生了大大小小的事故不下十次，每次都是又费人力又费财力，搞得所有人\(工程师、产品经理、director甚至是SVP\)焦头烂额。

从18年底开始，我们开始立项设计新一代的订单系统以期解决之前碰到的那些问题。上文也提到了，在一个异构的分布式微服务架构系统中，强一致性基本无望，只能退而求其次寻求最终一致性\(Eventual consistency\)。继续使用上文的例子，当订单服务C出故障时，我们挂起整个请求，等到C恢复时，我们恢复那个被挂起的请求重试C，此时订单最终能被创建成功，买家和卖家收到邮件确认订单创建成功。有心点的朋友也许会问，万一是B支付服务出故障呢，你如果重试多次不会导致买家被多次扣款么？确实会，不仅是B，其中的任何服务都会遇到这个问题，库存可以被更新两次，订单可以被创建两个。我们使用了**幂等性**\(idempotency\)来解决这个问题。所谓的幂等性，就是说一个操作被调用N次的结果和被调用1次的结果是相同的，用简单的数学表述为 `f(x)= f(x)f(x)...f(x)`。在这个最终一致性链上的所有操作必须实现幂等性。

此处我略过了很多设计细节，只是想粗略地提到一些关键的想法来帮助读者理解问题和解决思路。最终的系统实现就是一个高度定制化的、高可用性的、最终一致性的工作流引擎系统。从19年六月份上线到现在差不多半年时间里，有超过一万个订单如果没有这个新系统就出问题或流失了，直接的GMV贡献可达$500K。

#### 全链路实现Stripe SCA

